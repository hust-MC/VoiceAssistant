# 车载语音助手功能详细设计

## 📋 功能模块总览

```
车载语音助手
├── 一、媒体控制模块（真实实现）
│   ├── 1.1 播放控制
│   ├── 1.2 切歌控制
│   └── 1.3 音量控制
│
├── 二、系统控制模块（真实实现 + Mock）
│   ├── 2.1 亮度控制
│   ├── 2.2 WiFi控制
│   ├── 2.3 蓝牙控制
│   └── 2.4 系统设置
│
├── 三、车辆控制模块（全部Mock）
│   ├── 3.1 空调控制
│   ├── 3.2 座椅控制
│   ├── 3.3 车窗控制
│   ├── 3.4 灯光控制
│   ├── 3.5 车门控制
│   └── 3.6 启动控制
│
├── 四、信息查询模块（真实实现）
│   ├── 4.1 时间日期查询
│   ├── 4.2 天气查询
│   ├── 4.3 计算器
│   └── 4.4 单位换算
│
└── 五、对话交互模块（真实实现）
    ├── 5.1 语音识别
    ├── 5.2 语音合成
    ├── 5.3 意图识别
    └── 5.4 对话管理
```

---

## 一、媒体控制模块（真实实现）

### 1.1 播放控制

#### 功能1.1.1：播放音乐

**功能描述**：启动音乐播放

**支持的指令（指令变体）**：
```
- "播放"
- "播放音乐"
- "开始播放"
- "继续播放"
- "打开音乐"
- "放歌"
- "听歌"
- "播放歌曲"
```

**识别规则**：
```
关键词匹配：
- 包含"播放"或"放歌"或"听歌"
- 不包含"暂停"或"停止"
- 优先级：最高（多个匹配时优先选择）
```

**执行逻辑**：
```kotlin
1. 检查是否有活动的MediaSession
2. 如果有：
   - 调用 MediaController.transportControls.play()
   - 返回成功结果
3. 如果没有：
   - 返回错误："当前没有可播放的音乐"
```

**反馈内容**：
- 成功：TTS播报 "正在播放音乐"
- 失败：TTS播报 "当前没有可播放的音乐"
- UI显示：播放图标状态更新

**依赖和权限**：
- 依赖：MediaSession API（系统API，无需额外权限）
- 注意事项：需要有其他App正在使用MediaSession

---

#### 功能1.1.2：暂停播放

**功能描述**：暂停当前播放的音乐

**支持的指令**：
```
- "暂停"
- "暂停播放"
- "暂停音乐"
- "停止播放"（这里暂停和停止都做暂停处理）
- "暂停歌曲"
```

**识别规则**：
```
关键词匹配：
- 包含"暂停"或"停止"
- 不包含"播放"（避免和"暂停播放"冲突）
```

**执行逻辑**：
```kotlin
1. 检查是否有活动的MediaSession
2. 检查播放状态是否为正在播放
3. 如果是：
   - 调用 MediaController.transportControls.pause()
   - 返回成功
4. 如果不是：
   - 返回提示："当前没有播放的音乐"
```

**反馈内容**：
- 成功：TTS播报 "已暂停播放"
- 失败：TTS播报 "当前没有播放的音乐"

---

#### 功能1.1.3：停止播放

**功能描述**：完全停止播放（如果区分暂停和停止的话）

**支持的指令**：
```
- "停止"
- "停止播放"
- "停止音乐"
- "关闭音乐"
```

**识别规则**：
```
关键词匹配：
- 包含"停止"或"关闭"
- 优先级低于"暂停"
```

**执行逻辑**：
```kotlin
1. 调用 MediaController.transportControls.stop()
2. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "已停止播放"

**备注**：如果不需要区分暂停和停止，可以与暂停合并

---

### 1.2 切歌控制

#### 功能1.2.1：下一首

**功能描述**：切换到下一首歌曲

**支持的指令**：
```
- "下一首"
- "下一曲"
- "下一首歌"
- "下一首歌曲"
- "切歌"
- "下一首音乐"
- "播放下一首"
- "下一首吧"
- "换下一首"
```

**识别规则**：
```
关键词匹配：
- 包含"下一首"或"下一曲"或"切歌"
- 优先匹配"下一首"（更明确）
```

**执行逻辑**：
```kotlin
1. 检查是否有活动的MediaSession
2. 检查是否支持skipToNext（检查MediaController的播放控制能力）
3. 如果支持：
   - 调用 MediaController.transportControls.skipToNext()
   - 返回成功
4. 如果不支持：
   - 返回错误："不支持切歌功能"
```

**反馈内容**：
- 成功：TTS播报 "下一首"
- 失败：TTS播报 "不支持切歌功能"
- UI显示：歌曲信息更新（如果有）

**边界情况**：
- 播放列表只有一首歌：正常执行，可能没有变化
- 播放列表已到最后一首：根据播放器行为（循环或停止）

---

#### 功能1.2.2：上一首

**功能描述**：切换到上一首歌曲

**支持的指令**：
```
- "上一首"
- "上一曲"
- "上一首歌"
- "上一首歌曲"
- "上一首音乐"
- "播放上一首"
- "上一首吧"
- "换上一首"
- "返回上一首"
```

**识别规则**：
```
关键词匹配：
- 包含"上一首"或"上一曲"
- 优先级：与下一首相同
```

**执行逻辑**：
```kotlin
1. 检查是否有活动的MediaSession
2. 检查是否支持skipToPrevious
3. 如果支持：
   - 调用 MediaController.transportControls.skipToPrevious()
   - 返回成功
4. 如果不支持：
   - 返回错误："不支持切歌功能"
```

**反馈内容**：
- 成功：TTS播报 "上一首"
- 失败：TTS播报 "不支持切歌功能"

---

### 1.3 音量控制

#### 功能1.3.1：音量增大

**功能描述**：增大系统音量

**支持的指令**：
```
- "音量调大"
- "音量增大"
- "声音大一点"
- "声音大一些"
- "音量加"
- "音量增加"
- "调大音量"
- "增大音量"
- "提高音量"
- "音量调高"
- "声音调大"
```

**识别规则**：
```
关键词匹配：
- 包含"音量"或"声音"
- 同时包含"大"或"高"或"加"或"增"或"提高"或"调大"
- 不包含"小"或"低"或"减"
```

**执行逻辑**：
```kotlin
1. 获取AudioManager实例
2. 获取当前音量
3. 获取最大音量
4. 如果当前音量 < 最大音量：
   - 调用 audioManager.adjustVolume(AudioManager.ADJUST_RAISE, AudioManager.FLAG_SHOW_UI)
   - 获取新的音量值
   - 返回成功（包含音量信息）
5. 如果已经是最大音量：
   - 返回提示："音量已经是最大了"
```

**反馈内容**：
- 成功：TTS播报 "音量已调高，当前音量X"
- 最大：TTS播报 "音量已经是最大了"
- UI显示：音量进度条更新，显示音量值

**依赖和权限**：
- 依赖：AudioManager（系统API，无需额外权限）
- 注意：FLAG_SHOW_UI会显示系统音量UI，可以去掉这个flag

---

#### 功能1.3.2：音量减小

**功能描述**：减小系统音量

**支持的指令**：
```
- "音量调小"
- "音量减小"
- "声音小一点"
- "声音小一些"
- "音量减"
- "音量降低"
- "调小音量"
- "减小音量"
- "降低音量"
- "音量调低"
- "声音调小"
```

**识别规则**：
```
关键词匹配：
- 包含"音量"或"声音"
- 同时包含"小"或"低"或"减"或"降"或"降低"或"调小"
- 不包含"大"或"高"或"加"
```

**执行逻辑**：
```kotlin
1. 获取AudioManager实例
2. 获取当前音量
3. 如果当前音量 > 0：
   - 调用 audioManager.adjustVolume(AudioManager.ADJUST_LOWER, AudioManager.FLAG_SHOW_UI)
   - 获取新的音量值
   - 返回成功
4. 如果已经是静音或0：
   - 返回提示："音量已经是最小了"
```

**反馈内容**：
- 成功：TTS播报 "音量已调低，当前音量X"
- 最小：TTS播报 "音量已经是最小了"

---

#### 功能1.3.3：静音

**功能描述**：静音（音量设为0但不改变音量设置值）

**支持的指令**：
```
- "静音"
- "关闭声音"
- "关闭音量"
- "声音关闭"
- "音量关闭"
- "静音模式"
- "打开静音"
```

**识别规则**：
```
关键词匹配：
- 包含"静音"
- 或包含"关闭"且包含"声音"或"音量"
```

**执行逻辑**：
```kotlin
1. 调用 audioManager.adjustVolume(AudioManager.ADJUST_MUTE, 0)
2. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "已静音"
- UI显示：静音图标显示

**注意**：ADJUST_MUTE是临时静音，不会改变音量值

---

#### 功能1.3.4：取消静音

**功能描述**：取消静音

**支持的指令**：
```
- "取消静音"
- "关闭静音"
- "打开声音"
- "恢复声音"
- "恢复音量"
- "声音打开"
- "音量打开"
```

**识别规则**：
```
关键词匹配：
- 包含"取消静音"或"关闭静音"
- 或包含"打开"且包含"声音"或"音量"
- 或包含"恢复"且包含"声音"或"音量"
```

**执行逻辑**：
```kotlin
1. 调用 audioManager.adjustVolume(AudioManager.ADJUST_UNMUTE, 0)
2. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "已取消静音"
- UI显示：静音图标隐藏

---

## 二、系统控制模块（真实实现 + Mock）

### 2.1 亮度控制

#### 功能2.1.1：亮度增加

**功能描述**：增加屏幕亮度

**支持的指令**：
```
- "屏幕亮一点"
- "亮度调高"
- "亮度增加"
- "调亮屏幕"
- "屏幕调亮"
- "增加亮度"
- "提高亮度"
- "亮度加"
- "屏幕亮一些"
```

**识别规则**：
```
关键词匹配：
- 包含"屏幕"或"亮度"
- 同时包含"亮"或"高"或"加"或"增"或"提高"或"调亮"
```

**执行逻辑**：
```kotlin
1. 检查是否有WRITE_SETTINGS权限
2. 如果没有权限：
   - 请求权限（引导用户到设置页面）
   - 返回错误："需要屏幕亮度权限"
3. 如果有权限：
   - 获取当前亮度值（0-255）
   - 增加25（或根据当前值按比例增加）
   - 限制在0-255范围内
   - 调用 Settings.System.putInt(contentResolver, SCREEN_BRIGHTNESS, newValue)
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "屏幕亮度已调高"
- 无权限：TTS播报 "需要屏幕亮度权限，请到设置中开启"
- UI显示：亮度值更新（如果有显示）

**依赖和权限**：
- 权限：WRITE_SETTINGS（需要系统设置权限）
- 注意：Android 6.0+需要用户手动授权

**边界情况**：
- 已经是最大亮度：可以提示"已经是最大亮度了"或直接不操作
- 权限被拒绝：友好提示并引导用户

---

#### 功能2.1.2：亮度减少

**功能描述**：降低屏幕亮度

**支持的指令**：
```
- "屏幕暗一点"
- "亮度调低"
- "亮度降低"
- "调暗屏幕"
- "屏幕调暗"
- "降低亮度"
- "减少亮度"
- "亮度减"
- "屏幕暗一些"
```

**识别规则**：
```
关键词匹配：
- 包含"屏幕"或"亮度"
- 同时包含"暗"或"低"或"减"或"降"或"降低"或"调暗"
```

**执行逻辑**：
```kotlin
1. 检查WRITE_SETTINGS权限
2. 获取当前亮度值
3. 减少25（或按比例减少）
4. 限制在0-255范围内
5. 调用 Settings.System.putInt()
6. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "屏幕亮度已调低"
- 无权限：TTS播报 "需要屏幕亮度权限"
- 最小亮度：可以提示"已经是最暗了"

---

### 2.2 WiFi控制

#### 功能2.2.1：打开WiFi

**功能描述**：打开WiFi功能

**支持的指令**：
```
- "打开WiFi"
- "打开wifi"
- "开启WiFi"
- "开启wifi"
- "连接WiFi"
- "WiFi打开"
- "wifi打开"
- "启用WiFi"
```

**识别规则**：
```
关键词匹配：
- 包含"WiFi"或"wifi"（不区分大小写）
- 同时包含"打开"或"开启"或"连接"或"启用"
- 不包含"关闭"
```

**执行逻辑**：
```kotlin
1. 检查是否有CHANGE_WIFI_STATE权限
2. 获取WifiManager实例
3. 检查WiFi当前状态
4. 如果已打开：
   - 返回提示："WiFi已经打开了"
5. 如果已关闭：
   - 调用 wifiManager.isWifiEnabled = true
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "WiFi已打开"
- 已打开：TTS播报 "WiFi已经打开了"
- 无权限：TTS播报 "需要WiFi控制权限"

**依赖和权限**：
- 权限：CHANGE_WIFI_STATE（运行时权限）
- 依赖：WifiManager（系统服务）

---

#### 功能2.2.2：关闭WiFi

**功能描述**：关闭WiFi功能

**支持的指令**：
```
- "关闭WiFi"
- "关闭wifi"
- "断开WiFi"
- "WiFi关闭"
- "wifi关闭"
- "禁用WiFi"
```

**识别规则**：
```
关键词匹配：
- 包含"WiFi"或"wifi"
- 同时包含"关闭"或"断开"或"禁用"
```

**执行逻辑**：
```kotlin
1. 检查CHANGE_WIFI_STATE权限
2. 获取WifiManager实例
3. 检查WiFi当前状态
4. 如果已关闭：
   - 返回提示："WiFi已经关闭了"
5. 如果已打开：
   - 调用 wifiManager.isWifiEnabled = false
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "WiFi已关闭"
- 已关闭：TTS播报 "WiFi已经关闭了"

---

#### 功能2.2.3：查询WiFi状态

**功能描述**：查询WiFi当前状态

**支持的指令**：
```
- "WiFi状态"
- "wifi状态"
- "WiFi开了吗"
- "wifi开了吗"
- "WiFi是开的吗"
- "检查WiFi"
```

**识别规则**：
```
关键词匹配：
- 包含"WiFi"或"wifi"
- 同时包含"状态"或"开了吗"或"检查"
```

**执行逻辑**：
```kotlin
1. 检查ACCESS_WIFI_STATE权限（读取权限）
2. 获取WifiManager实例
3. 检查 wifiManager.isWifiEnabled
4. 返回状态信息
```

**反馈内容**：
- 已打开：TTS播报 "WiFi已打开"
- 已关闭：TTS播报 "WiFi已关闭"

---

### 2.3 蓝牙控制

#### 功能2.3.1：打开蓝牙

**功能描述**：打开蓝牙功能

**支持的指令**：
```
- "打开蓝牙"
- "开启蓝牙"
- "启用蓝牙"
- "蓝牙打开"
- "连接蓝牙"
```

**识别规则**：
```
关键词匹配：
- 包含"蓝牙"
- 同时包含"打开"或"开启"或"启用"或"连接"
- 不包含"关闭"
```

**执行逻辑**：
```kotlin
1. 检查BLUETOOTH_ADMIN权限
2. 获取BluetoothAdapter
3. 如果设备不支持蓝牙：
   - 返回错误："设备不支持蓝牙"
4. 检查蓝牙当前状态
5. 如果已打开：
   - 返回提示："蓝牙已经打开了"
6. 如果已关闭：
   - 调用 bluetoothAdapter.enable()
   - 返回成功（注意：enable()是异步的）
```

**反馈内容**：
- 成功：TTS播报 "蓝牙已打开"
- 已打开：TTS播报 "蓝牙已经打开了"
- 不支持：TTS播报 "设备不支持蓝牙"
- 无权限：TTS播报 "需要蓝牙控制权限"

**依赖和权限**：
- 权限：BLUETOOTH_ADMIN（运行时权限）
- 注意：enable()是异步操作，可能需要监听状态变化

---

#### 功能2.3.2：关闭蓝牙

**功能描述**：关闭蓝牙功能

**支持的指令**：
```
- "关闭蓝牙"
- "断开蓝牙"
- "蓝牙关闭"
- "禁用蓝牙"
```

**识别规则**：
```
关键词匹配：
- 包含"蓝牙"
- 同时包含"关闭"或"断开"或"禁用"
```

**执行逻辑**：
```kotlin
1. 检查BLUETOOTH_ADMIN权限
2. 获取BluetoothAdapter
3. 检查蓝牙当前状态
4. 如果已关闭：
   - 返回提示："蓝牙已经关闭了"
5. 如果已打开：
   - 调用 bluetoothAdapter.disable()
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "蓝牙已关闭"
- 已关闭：TTS播报 "蓝牙已经关闭了"

---

#### 功能2.3.3：查询蓝牙状态

**功能描述**：查询蓝牙当前状态

**支持的指令**：
```
- "蓝牙状态"
- "蓝牙开了吗"
- "检查蓝牙"
```

**识别规则**：
```
关键词匹配：
- 包含"蓝牙"
- 同时包含"状态"或"开了吗"或"检查"
```

**执行逻辑**：
```kotlin
1. 检查BLUETOOTH权限（读取权限）
2. 获取BluetoothAdapter
3. 检查 bluetoothAdapter?.isEnabled
4. 返回状态信息
```

**反馈内容**：
- 已打开：TTS播报 "蓝牙已打开"
- 已关闭：TTS播报 "蓝牙已关闭"

---

### 2.4 系统设置

#### 功能2.4.1：打开系统设置

**功能描述**：打开Android系统设置页面

**支持的指令**：
```
- "打开设置"
- "进入设置"
- "系统设置"
- "打开系统设置"
- "设置"
```

**识别规则**：
```
关键词匹配：
- 包含"设置"
- 可选包含"打开"或"进入"或"系统"
```

**执行逻辑**：
```kotlin
1. 创建Intent(Intent.ACTION_SETTINGS)
2. 调用 context.startActivity(intent)
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "已打开设置"
- 失败：TTS播报 "无法打开设置"（一般不会失败）

**依赖和权限**：
- 无需特殊权限（打开系统设置是公开API）

---

## 三、车辆控制模块（全部Mock）

### 3.1 空调控制

#### 功能3.1.1：打开空调

**功能描述**：打开车载空调（Mock模拟）

**支持的指令**：
```
- "打开空调"
- "开启空调"
- "启动空调"
- "空调打开"
- "开空调"
- "打开AC"
```

**识别规则**：
```
关键词匹配：
- 包含"空调"或"AC"
- 同时包含"打开"或"开启"或"启动"或"开"
- 不包含"关闭"
```

**执行逻辑**：
```kotlin
1. 获取当前车辆状态（Mock数据）
2. 如果空调已打开：
   - 返回提示："空调已经打开了"
3. 如果空调已关闭：
   - 更新车辆状态：ac.isOn = true
   - 设置默认温度：ac.temperature = 24
   - 设置默认风速：ac.fanSpeed = 3
   - 更新UI状态（车辆控制面板）
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "空调已打开，当前温度24度"
- 已打开：TTS播报 "空调已经打开了"
- UI显示：车辆状态面板更新，显示空调状态

**Mock数据结构**：
```kotlin
data class ACState(
    var isOn: Boolean = false,
    var temperature: Int = 24,  // 16-32度
    var fanSpeed: Int = 3,      // 1-5档
    var mode: ACMode = ACMode.AUTO
)
```

---

#### 功能3.1.2：关闭空调

**功能描述**：关闭车载空调（Mock）

**支持的指令**：
```
- "关闭空调"
- "关闭AC"
- "空调关闭"
- "关空调"
- "停止空调"
```

**识别规则**：
```
关键词匹配：
- 包含"空调"或"AC"
- 同时包含"关闭"或"关"或"停止"
```

**执行逻辑**：
```kotlin
1. 获取当前车辆状态
2. 如果空调已关闭：
   - 返回提示："空调已经关闭了"
3. 如果空调已打开：
   - 更新车辆状态：ac.isOn = false
   - 更新UI状态
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "空调已关闭"
- 已关闭：TTS播报 "空调已经关闭了"

---

#### 功能3.1.3：温度调高

**功能描述**：提高空调温度（Mock）

**支持的指令**：
```
- "温度调高"
- "温度升高"
- "温度加"
- "温度高一点"
- "温度高一些"
- "提高温度"
- "增加温度"
- "空调温度调高"
- "温度调高点"
```

**识别规则**：
```
关键词匹配：
- 包含"温度"
- 同时包含"高"或"加"或"升"或"提高"或"增加"或"调高"
- 不包含"低"或"减"
```

**执行逻辑**：
```kotlin
1. 检查空调是否打开
2. 如果空调未打开：
   - 返回提示："请先打开空调"
3. 如果空调已打开：
   - 获取当前温度
   - 增加1度
   - 限制在16-32度范围内
   - 如果已达到最大值：
     - 返回提示："温度已经是最高了"
   - 否则：
     - 更新状态：ac.temperature = newTemp
     - 更新UI
     - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "温度已调高至X度"
- 未打开：TTS播报 "请先打开空调"
- 最高：TTS播报 "温度已经是最高了，32度"

---

#### 功能3.1.4：温度调低

**功能描述**：降低空调温度（Mock）

**支持的指令**：
```
- "温度调低"
- "温度降低"
- "温度减"
- "温度低一点"
- "温度低一些"
- "降低温度"
- "减少温度"
- "空调温度调低"
- "温度调低点"
```

**识别规则**：
```
关键词匹配：
- 包含"温度"
- 同时包含"低"或"减"或"降"或"降低"或"减少"或"调低"
- 不包含"高"或"加"
```

**执行逻辑**：
```kotlin
1. 检查空调是否打开
2. 如果空调未打开：
   - 返回提示："请先打开空调"
3. 如果空调已打开：
   - 获取当前温度
   - 减少1度
   - 限制在16-32度范围内
   - 如果已达到最小值：
     - 返回提示："温度已经是最低了"
   - 否则：
     - 更新状态：ac.temperature = newTemp
     - 更新UI
     - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "温度已调低至X度"
- 未打开：TTS播报 "请先打开空调"
- 最低：TTS播报 "温度已经是最低了，16度"

---

#### 功能3.1.5：设置指定温度

**功能描述**：将空调设置到指定温度（Mock）

**支持的指令**：
```
- "温度调到26度"
- "温度设置为26"
- "设置为26度"
- "调到26度"
- "26度"
- "温度26"
- "空调26度"
```

**识别规则**：
```
关键词匹配：
- 包含"温度"或"度"（可选）
- 包含数字（16-32之间的数字）
- 可选包含"调到"或"设置"或"设为"
```

**执行逻辑**：
```kotlin
1. 从指令中提取数字（正则表达式）
2. 验证数字是否在16-32范围内
3. 检查空调是否打开
4. 如果空调未打开：
   - 可以先自动打开空调
   - 或提示："请先打开空调"
5. 如果温度超出范围：
   - 返回错误："温度只能在16到32度之间"
6. 如果正常：
   - 更新状态：ac.temperature = extractedTemp
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "温度已设置为X度"
- 未打开：TTS播报 "请先打开空调"
- 范围错误：TTS播报 "温度只能在16到32度之间"

**数字提取示例**：
```kotlin
private fun extractTemperature(text: String): Int? {
    val regex = """(\d+)度?""".toRegex()
    val match = regex.find(text)
    return match?.groupValues?.get(1)?.toIntOrNull()
}
```

---

#### 功能3.1.6：风速调高

**功能描述**：提高空调风速（Mock）

**支持的指令**：
```
- "风速调大"
- "风速调高"
- "风速增加"
- "风大一点"
- "风大一些"
- "风速加"
- "提高风速"
- "空调风速调大"
```

**识别规则**：
```
关键词匹配：
- 包含"风速"或"风"（但要注意和"空调风"区分）
- 同时包含"大"或"高"或"加"或"增加"或"提高"或"调大"
- 上下文包含"空调"（可选，帮助区分）
```

**执行逻辑**：
```kotlin
1. 检查空调是否打开
2. 如果空调未打开：
   - 返回提示："请先打开空调"
3. 如果空调已打开：
   - 获取当前风速（1-5档）
   - 如果已经是5档：
     - 返回提示："风速已经是最大了"
   - 否则：
     - 增加1档
     - 更新状态：ac.fanSpeed = newSpeed
     - 更新UI
     - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "风速已调高至X档"
- 未打开：TTS播报 "请先打开空调"
- 最大：TTS播报 "风速已经是最大了，5档"

---

#### 功能3.1.7：风速调低

**功能描述**：降低空调风速（Mock）

**支持的指令**：
```
- "风速调小"
- "风速调低"
- "风速降低"
- "风小一点"
- "风小一些"
- "风速减"
- "降低风速"
- "空调风速调小"
```

**识别规则**：
```
关键词匹配：
- 包含"风速"或"风"
- 同时包含"小"或"低"或"减"或"降低"或"调小"
```

**执行逻辑**：
```kotlin
1. 检查空调是否打开
2. 如果空调未打开：
   - 返回提示："请先打开空调"
3. 如果空调已打开：
   - 获取当前风速
   - 如果已经是1档：
     - 返回提示："风速已经是最小了"
   - 否则：
     - 减少1档
     - 更新状态：ac.fanSpeed = newSpeed
     - 更新UI
     - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "风速已调低至X档"
- 未打开：TTS播报 "请先打开空调"
- 最小：TTS播报 "风速已经是最小了，1档"

---

#### 功能3.1.8：切换空调模式

**功能描述**：切换空调模式（自动/制冷/制热）（Mock）

**支持的指令**：
```
自动模式：
- "自动模式"
- "自动"
- "切换到自动模式"
- "空调自动"

制冷模式：
- "制冷"
- "冷风"
- "制冷模式"
- "切换到制冷模式"
- "开冷风"

制热模式：
- "制热"
- "暖风"
- "制热模式"
- "切换到制热模式"
- "开暖风"
```

**识别规则**：
```
自动模式：
- 包含"自动"且包含"模式"（可选）

制冷模式：
- 包含"制冷"或"冷风"

制热模式：
- 包含"制热"或"暖风"
```

**执行逻辑**：
```kotlin
1. 检查空调是否打开
2. 如果空调未打开：
   - 返回提示："请先打开空调"
3. 如果空调已打开：
   - 根据指令确定目标模式
   - 如果目标模式与当前模式相同：
     - 返回提示："已经是X模式了"
   - 否则：
     - 更新状态：ac.mode = targetMode
     - 更新UI
     - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "已切换到X模式"
- 未打开：TTS播报 "请先打开空调"
- 相同模式：TTS播报 "已经是X模式了"

**Mock数据结构**：
```kotlin
enum class ACMode {
    AUTO,   // 自动
    COOL,   // 制冷
    HEAT    // 制热
}
```

---

### 3.2 座椅控制

#### 功能3.2.1：座椅前移

**功能描述**：座椅向前移动（Mock）

**支持的指令**：
```
- "座椅前移"
- "座椅往前"
- "座椅向前"
- "座椅调前"
- "前移座椅"
- "座椅往前一点"
```

**识别规则**：
```
关键词匹配：
- 包含"座椅"
- 同时包含"前"或"往前"或"向前"
- 不包含"后"
```

**执行逻辑**：
```kotlin
1. 获取当前座椅位置（1-5档）
2. 如果已经是5档（最前）：
   - 返回提示："座椅已经是最前了"
3. 否则：
   - 增加1档
   - 更新状态：seat.position = newPosition
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "座椅已前移"
- 最前：TTS播报 "座椅已经是最前了"

**Mock数据结构**：
```kotlin
data class SeatState(
    var position: Int = 3,  // 1-5档，3是中间位置
    var heating: Boolean = false,
    var ventilation: Boolean = false
)
```

---

#### 功能3.2.2：座椅后移

**功能描述**：座椅向后移动（Mock）

**支持的指令**：
```
- "座椅后移"
- "座椅往后"
- "座椅向后"
- "座椅调后"
- "后移座椅"
- "座椅往后一点"
```

**识别规则**：
```
关键词匹配：
- 包含"座椅"
- 同时包含"后"或"往后"或"向后"
- 不包含"前"
```

**执行逻辑**：
```kotlin
1. 获取当前座椅位置
2. 如果已经是1档（最后）：
   - 返回提示："座椅已经是最后了"
3. 否则：
   - 减少1档
   - 更新状态：seat.position = newPosition
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "座椅已后移"
- 最后：TTS播报 "座椅已经是最后了"

---

#### 功能3.2.3：座椅加热

**功能描述**：打开座椅加热（Mock）

**支持的指令**：
```
- "座椅加热"
- "加热座椅"
- "打开座椅加热"
- "开启座椅加热"
- "座椅加热打开"
```

**识别规则**：
```
关键词匹配：
- 包含"座椅"
- 同时包含"加热"
- 可选包含"打开"或"开启"
```

**执行逻辑**：
```kotlin
1. 获取当前座椅状态
2. 如果加热已打开：
   - 返回提示："座椅加热已经打开了"
3. 如果加热已关闭：
   - 更新状态：seat.heating = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "座椅加热已打开"
- 已打开：TTS播报 "座椅加热已经打开了"

---

#### 功能3.2.4：关闭座椅加热

**功能描述**：关闭座椅加热（Mock）

**支持的指令**：
```
- "关闭座椅加热"
- "座椅加热关闭"
- "停止座椅加热"
- "关闭加热"
```

**识别规则**：
```
关键词匹配：
- 包含"座椅"和"加热"
- 同时包含"关闭"或"停止"
```

**执行逻辑**：
```kotlin
1. 获取当前座椅状态
2. 如果加热已关闭：
   - 返回提示："座椅加热已经关闭了"
3. 如果加热已打开：
   - 更新状态：seat.heating = false
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "座椅加热已关闭"
- 已关闭：TTS播报 "座椅加热已经关闭了"

---

#### 功能3.2.5：座椅通风

**功能描述**：打开座椅通风（Mock）

**支持的指令**：
```
- "座椅通风"
- "通风座椅"
- "打开座椅通风"
- "开启座椅通风"
- "座椅通风打开"
```

**识别规则**：
```
关键词匹配：
- 包含"座椅"
- 同时包含"通风"
- 可选包含"打开"或"开启"
```

**执行逻辑**：
```kotlin
1. 获取当前座椅状态
2. 如果通风已打开：
   - 返回提示："座椅通风已经打开了"
3. 如果通风已关闭：
   - 更新状态：seat.ventilation = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "座椅通风已打开"
- 已打开：TTS播报 "座椅通风已经打开了"

---

#### 功能3.2.6：座椅复位

**功能描述**：座椅恢复到默认位置（Mock）

**支持的指令**：
```
- "座椅复位"
- "座椅恢复"
- "恢复座椅位置"
- "座椅位置恢复"
- "座椅回位"
```

**识别规则**：
```
关键词匹配：
- 包含"座椅"
- 同时包含"复位"或"恢复"或"回位"
```

**执行逻辑**：
```kotlin
1. 更新状态：seat.position = 3（默认中间位置）
2. 更新UI
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "座椅已复位"

---

### 3.3 车窗控制

#### 功能3.3.1：打开前窗

**功能描述**：打开前车窗（Mock）

**支持的指令**：
```
- "打开前窗"
- "前窗打开"
- "打开前面车窗"
- "前窗降下"
- "放下前窗"
```

**识别规则**：
```
关键词匹配：
- 包含"前窗"或"前面车窗"
- 同时包含"打开"或"降下"或"放下"
- 不包含"关闭"
```

**执行逻辑**：
```kotlin
1. 获取当前车窗状态
2. 如果前窗已完全打开（100%）：
   - 返回提示："前窗已经完全打开了"
3. 否则：
   - 更新状态：window.frontLeft = 100, window.frontRight = 100
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "前窗已打开"
- 已打开：TTS播报 "前窗已经完全打开了"

**Mock数据结构**：
```kotlin
data class WindowState(
    var frontLeft: Int = 0,   // 0-100%，0是完全关闭
    var frontRight: Int = 0,
    var rearLeft: Int = 0,
    var rearRight: Int = 0,
    var sunroof: Boolean = false
)
```

---

#### 功能3.3.2：关闭前窗

**功能描述**：关闭前车窗（Mock）

**支持的指令**：
```
- "关闭前窗"
- "前窗关闭"
- "关闭前面车窗"
- "前窗升起"
- "升起前窗"
```

**识别规则**：
```
关键词匹配：
- 包含"前窗"或"前面车窗"
- 同时包含"关闭"或"升起"
```

**执行逻辑**：
```kotlin
1. 获取当前车窗状态
2. 如果前窗已完全关闭（0%）：
   - 返回提示："前窗已经完全关闭了"
3. 否则：
   - 更新状态：window.frontLeft = 0, window.frontRight = 0
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "前窗已关闭"
- 已关闭：TTS播报 "前窗已经完全关闭了"

---

#### 功能3.3.3：前窗打开一半

**功能描述**：前窗打开到50%（Mock）

**支持的指令**：
```
- "前窗打开一半"
- "前窗一半"
- "前窗50%"
- "前窗打开50%"
```

**识别规则**：
```
关键词匹配：
- 包含"前窗"
- 同时包含"一半"或"50%"
```

**执行逻辑**：
```kotlin
1. 更新状态：window.frontLeft = 50, window.frontRight = 50
2. 更新UI
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "前窗已打开一半"

---

#### 功能3.3.4：打开后窗

**功能描述**：打开后车窗（Mock）

**支持的指令**：
```
- "打开后窗"
- "后窗打开"
- "打开后面车窗"
- "后窗降下"
```

**识别规则**：
```
关键词匹配：
- 包含"后窗"或"后面车窗"
- 同时包含"打开"或"降下"
```

**执行逻辑**：
```kotlin
1. 更新状态：window.rearLeft = 100, window.rearRight = 100
2. 更新UI
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "后窗已打开"

---

#### 功能3.3.5：关闭后窗

**功能描述**：关闭后车窗（Mock）

**支持的指令**：
```
- "关闭后窗"
- "后窗关闭"
- "关闭后面车窗"
- "后窗升起"
```

**识别规则**：
```
关键词匹配：
- 包含"后窗"或"后面车窗"
- 同时包含"关闭"或"升起"
```

**执行逻辑**：
```kotlin
1. 更新状态：window.rearLeft = 0, window.rearRight = 0
2. 更新UI
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "后窗已关闭"

---

#### 功能3.3.6：打开天窗

**功能描述**：打开天窗（Mock）

**支持的指令**：
```
- "打开天窗"
- "天窗打开"
- "开启天窗"
- "天窗开启"
```

**识别规则**：
```
关键词匹配：
- 包含"天窗"
- 同时包含"打开"或"开启"
```

**执行逻辑**：
```kotlin
1. 获取当前天窗状态
2. 如果天窗已打开：
   - 返回提示："天窗已经打开了"
3. 如果天窗已关闭：
   - 更新状态：window.sunroof = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "天窗已打开"
- 已打开：TTS播报 "天窗已经打开了"

---

#### 功能3.3.7：关闭天窗

**功能描述**：关闭天窗（Mock）

**支持的指令**：
```
- "关闭天窗"
- "天窗关闭"
```

**识别规则**：
```
关键词匹配：
- 包含"天窗"
- 同时包含"关闭"
```

**执行逻辑**：
```kotlin
1. 获取当前天窗状态
2. 如果天窗已关闭：
   - 返回提示："天窗已经关闭了"
3. 如果天窗已打开：
   - 更新状态：window.sunroof = false
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "天窗已关闭"
- 已关闭：TTS播报 "天窗已经关闭了"

---

### 3.4 灯光控制

#### 功能3.4.1：打开大灯

**功能描述**：打开车辆大灯（Mock）

**支持的指令**：
```
- "打开大灯"
- "大灯打开"
- "开启大灯"
- "开大灯"
```

**识别规则**：
```
关键词匹配：
- 包含"大灯"
- 同时包含"打开"或"开启"或"开"
```

**执行逻辑**：
```kotlin
1. 获取当前灯光状态
2. 如果大灯已打开：
   - 返回提示："大灯已经打开了"
3. 如果大灯已关闭：
   - 更新状态：light.headlight = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "大灯已打开"
- 已打开：TTS播报 "大灯已经打开了"

**Mock数据结构**：
```kotlin
data class LightState(
    var headlight: Boolean = false,
    var headlightMode: HeadlightMode = HeadlightMode.AUTO,
    var ambientLight: Boolean = false,
    var ambientColor: String = "白色"
)

enum class HeadlightMode {
    OFF,    // 关闭
    ON,     // 开启
    AUTO    // 自动
}
```

---

#### 功能3.4.2：关闭大灯

**功能描述**：关闭车辆大灯（Mock）

**支持的指令**：
```
- "关闭大灯"
- "大灯关闭"
- "关大灯"
```

**识别规则**：
```
关键词匹配：
- 包含"大灯"
- 同时包含"关闭"或"关"
```

**执行逻辑**：
```kotlin
1. 更新状态：light.headlight = false, light.headlightMode = HeadlightMode.OFF
2. 更新UI
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "大灯已关闭"

---

#### 功能3.4.3：自动大灯

**功能描述**：设置大灯为自动模式（Mock）

**支持的指令**：
```
- "自动大灯"
- "大灯自动"
- "切换到自动大灯"
- "大灯自动模式"
```

**识别规则**：
```
关键词匹配：
- 包含"大灯"
- 同时包含"自动"
```

**执行逻辑**：
```kotlin
1. 更新状态：light.headlightMode = HeadlightMode.AUTO
2. 更新UI
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "已切换到自动大灯"

---

#### 功能3.4.4：打开氛围灯

**功能描述**：打开车内氛围灯（Mock）

**支持的指令**：
```
- "打开氛围灯"
- "氛围灯打开"
- "开启氛围灯"
- "氛围灯开启"
- "开氛围灯"
```

**识别规则**：
```
关键词匹配：
- 包含"氛围灯"
- 同时包含"打开"或"开启"或"开"
```

**执行逻辑**：
```kotlin
1. 获取当前灯光状态
2. 如果氛围灯已打开：
   - 返回提示："氛围灯已经打开了"
3. 如果氛围灯已关闭：
   - 更新状态：light.ambientLight = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "氛围灯已打开"
- 已打开：TTS播报 "氛围灯已经打开了"

---

#### 功能3.4.5：关闭氛围灯

**功能描述**：关闭车内氛围灯（Mock）

**支持的指令**：
```
- "关闭氛围灯"
- "氛围灯关闭"
- "关氛围灯"
```

**识别规则**：
```
关键词匹配：
- 包含"氛围灯"
- 同时包含"关闭"或"关"
```

**执行逻辑**：
```kotlin
1. 更新状态：light.ambientLight = false
2. 更新UI
3. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "氛围灯已关闭"

---

#### 功能3.4.6：设置氛围灯颜色

**功能描述**：设置氛围灯颜色（Mock）

**支持的指令**：
```
- "氛围灯调成蓝色"
- "氛围灯蓝色"
- "氛围灯改成红色"
- "氛围灯设置为绿色"
- "蓝色氛围灯"
- "红色氛围灯"
```

**识别规则**：
```
关键词匹配：
- 包含"氛围灯"
- 包含颜色关键词：红、橙、黄、绿、青、蓝、紫、白等
- 可选包含"调成"或"改成"或"设置为"
```

**执行逻辑**：
```kotlin
1. 从指令中提取颜色关键词
2. 检查氛围灯是否打开
3. 如果氛围灯未打开：
   - 可以先自动打开氛围灯
   - 或提示："请先打开氛围灯"
4. 匹配颜色关键词到颜色名称
5. 更新状态：light.ambientColor = extractedColor
6. 更新UI
7. 返回成功
```

**反馈内容**：
- 成功：TTS播报 "氛围灯已调成X色"
- 未打开：TTS播报 "请先打开氛围灯"

**颜色匹配示例**：
```kotlin
private fun extractColor(text: String): String? {
    val colorMap = mapOf(
        "红" to "红色",
        "橙" to "橙色",
        "黄" to "黄色",
        "绿" to "绿色",
        "青" to "青色",
        "蓝" to "蓝色",
        "紫" to "紫色",
        "白" to "白色"
    )
    
    colorMap.forEach { (key, value) ->
        if (text.contains(key)) return value
    }
    return "蓝色" // 默认颜色
}
```

---

### 3.5 车门控制

#### 功能3.5.1：锁车

**功能描述**：锁定车辆（Mock）

**支持的指令**：
```
- "锁车"
- "锁定车辆"
- "锁车门"
- "车门锁定"
- "上锁"
```

**识别规则**：
```
关键词匹配：
- 包含"锁"且包含"车"或"门"
- 或单独包含"锁车"
- 不包含"解锁"
```

**执行逻辑**：
```kotlin
1. 获取当前车门状态
2. 如果已锁定：
   - 返回提示："车辆已经锁定了"
3. 如果未锁定：
   - 更新状态：door.isLocked = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "车辆已锁定"
- 已锁定：TTS播报 "车辆已经锁定了"

**Mock数据结构**：
```kotlin
data class DoorState(
    var isLocked: Boolean = true,
    var trunkOpen: Boolean = false
)
```

---

#### 功能3.5.2：解锁

**功能描述**：解锁车辆（Mock）

**支持的指令**：
```
- "解锁"
- "解锁车辆"
- "车门解锁"
- "开锁"
- "解除锁定"
```

**识别规则**：
```
关键词匹配：
- 包含"解锁"或"开锁"
- 可选包含"车"或"门"
```

**执行逻辑**：
```kotlin
1. 获取当前车门状态
2. 如果未锁定：
   - 返回提示："车辆已经解锁了"
3. 如果已锁定：
   - 更新状态：door.isLocked = false
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "车辆已解锁"
- 已解锁：TTS播报 "车辆已经解锁了"

---

#### 功能3.5.3：打开后备箱

**功能描述**：打开后备箱（Mock）

**支持的指令**：
```
- "打开后备箱"
- "后备箱打开"
- "开启后备箱"
- "开后备箱"
- "打开后备厢"
```

**识别规则**：
```
关键词匹配：
- 包含"后备箱"或"后备厢"
- 同时包含"打开"或"开启"或"开"
```

**执行逻辑**：
```kotlin
1. 获取当前车门状态
2. 如果后备箱已打开：
   - 返回提示："后备箱已经打开了"
3. 如果后备箱已关闭：
   - 更新状态：door.trunkOpen = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "后备箱已打开"
- 已打开：TTS播报 "后备箱已经打开了"

---

#### 功能3.5.4：关闭后备箱

**功能描述**：关闭后备箱（Mock）

**支持的指令**：
```
- "关闭后备箱"
- "后备箱关闭"
- "关后备箱"
- "关闭后备厢"
```

**识别规则**：
```
关键词匹配：
- 包含"后备箱"或"后备厢"
- 同时包含"关闭"或"关"
```

**执行逻辑**：
```kotlin
1. 获取当前车门状态
2. 如果后备箱已关闭：
   - 返回提示："后备箱已经关闭了"
3. 如果后备箱已打开：
   - 更新状态：door.trunkOpen = false
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "后备箱已关闭"
- 已关闭：TTS播报 "后备箱已经关闭了"

---

### 3.6 启动控制

#### 功能3.6.1：启动车辆

**功能描述**：启动车辆（Mock）

**支持的指令**：
```
- "启动车辆"
- "启动"
- "启动汽车"
- "点火"
- "发动"
- "启动引擎"
```

**识别规则**：
```
关键词匹配：
- 包含"启动"或"点火"或"发动"
- 可选包含"车辆"或"汽车"或"引擎"
```

**执行逻辑**：
```kotlin
1. 获取当前车辆状态
2. 如果车辆已启动：
   - 返回提示："车辆已经启动了"
3. 如果车辆未启动：
   - 更新状态：engine.isRunning = true
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "车辆已启动"
- 已启动：TTS播报 "车辆已经启动了"

**Mock数据结构**：
```kotlin
data class EngineState(
    var isRunning: Boolean = false
)
```

---

#### 功能3.6.2：熄火

**功能描述**：熄火（Mock）

**支持的指令**：
```
- "熄火"
- "关闭车辆"
- "关闭汽车"
- "停止引擎"
- "熄火停车"
```

**识别规则**：
```
关键词匹配：
- 包含"熄火"或"关闭"且包含"车辆"或"汽车"或"引擎"
- 或单独包含"熄火"
```

**执行逻辑**：
```kotlin
1. 获取当前车辆状态
2. 如果车辆未启动：
   - 返回提示："车辆已经熄火了"
3. 如果车辆已启动：
   - 更新状态：engine.isRunning = false
   - 更新UI
   - 返回成功
```

**反馈内容**：
- 成功：TTS播报 "车辆已熄火"
- 已熄火：TTS播报 "车辆已经熄火了"

---

## 四、信息查询模块（真实实现）

### 4.1 时间日期查询

#### 功能4.1.1：查询当前时间

**功能描述**：查询当前时间

**支持的指令**：
```
- "现在几点"
- "几点了"
- "当前时间"
- "现在时间"
- "现在几点钟"
- "时间"
```

**识别规则**：
```
关键词匹配：
- 包含"时间"或"几点"
- 可选包含"现在"或"当前"
```

**执行逻辑**：
```kotlin
1. 获取系统当前时间
2. 格式化时间（例如：14点30分）
3. 返回结果
```

**反馈内容**：
- 成功：TTS播报 "现在时间是14点30分"

**代码示例**：
```kotlin
fun getCurrentTime(): String {
    val sdf = SimpleDateFormat("HH点mm分", Locale.CHINESE)
    return "现在时间是${sdf.format(Date())}"
}
```

---

#### 功能4.1.2：查询当前日期

**功能描述**：查询当前日期

**支持的指令**：
```
- "今天几号"
- "今天日期"
- "今天是几号"
- "当前日期"
- "日期"
- "今天几月几号"
```

**识别规则**：
```
关键词匹配：
- 包含"日期"或"几号"
- 可选包含"今天"或"当前"
```

**执行逻辑**：
```kotlin
1. 获取系统当前日期
2. 格式化日期（例如：2024年1月15日）
3. 返回结果
```

**反馈内容**：
- 成功：TTS播报 "今天是2024年1月15日"

**代码示例**：
```kotlin
fun getCurrentDate(): String {
    val sdf = SimpleDateFormat("yyyy年MM月dd日", Locale.CHINESE)
    return "今天是${sdf.format(Date())}"
}
```

---

#### 功能4.1.3：查询星期几

**功能描述**：查询今天是星期几

**支持的指令**：
```
- "今天星期几"
- "星期几"
- "今天周几"
- "周几"
- "今天是星期几"
```

**识别规则**：
```
关键词匹配：
- 包含"星期"或"周"
- 可选包含"今天"或"当前"
```

**执行逻辑**：
```kotlin
1. 获取系统当前日期
2. 计算是星期几
3. 转换为中文（星期一、星期二等）
4. 返回结果
```

**反馈内容**：
- 成功：TTS播报 "今天是星期一"

**代码示例**：
```kotlin
fun getDayOfWeek(): String {
    val calendar = Calendar.getInstance()
    val day = calendar.get(Calendar.DAY_OF_WEEK)
    val weekdays = arrayOf(
        "", "星期日", "星期一", "星期二", 
        "星期三", "星期四", "星期五", "星期六"
    )
    return "今天是${weekdays[day]}"
}
```

---

### 4.2 天气查询

#### 功能4.2.1：查询当前天气

**功能描述**：查询指定城市的当前天气

**支持的指令**：
```
- "今天天气怎么样"
- "天气如何"
- "天气"
- "今天天气"
- "北京天气"
- "上海天气怎么样"
- "查询天气"
```

**识别规则**：
```
关键词匹配：
- 包含"天气"
- 可选包含城市名称（北京、上海等）
- 可选包含"今天"或"当前"
```

**执行逻辑**：
```kotlin
1. 从指令中提取城市名称（如果有）
2. 如果没有指定城市，使用默认城市（可通过GPS获取）
3. 调用天气API获取天气信息
4. 解析返回的天气数据
5. 格式化天气信息
6. 返回结果
```

**反馈内容**：
- 成功：TTS播报 "北京今天晴天，温度25度，湿度60%，南风3级"
- 失败：TTS播报 "无法获取天气信息，请检查网络连接"

**依赖**：
- 需要天气API（如OpenWeatherMap、和风天气等）
- 需要网络连接

**天气信息包含**：
- 天气描述（晴天、多云、雨天等）
- 温度（当前温度、最高温度、最低温度）
- 湿度
- 风向和风速
- 空气质量（可选）

---

### 4.3 计算器

#### 功能4.3.1：简单计算

**功能描述**：执行简单的数学计算

**支持的指令**：
```
- "100加200等于多少"
- "100+200"
- "500减200"
- "500-200"
- "50乘2"
- "50*2"
- "100除以2"
- "100/2"
- "100加200"
- "500减200等于多少"
```

**识别规则**：
```
关键词匹配：
- 包含数字
- 包含运算符：加、减、乘、除、+、-、*、/
```

**执行逻辑**：
```kotlin
1. 从指令中提取数字和运算符（正则表达式）
2. 验证数字和运算符的有效性
3. 执行计算
4. 处理除零错误
5. 返回结果
```

**反馈内容**：
- 成功：TTS播报 "等于300"
- 除零错误：TTS播报 "除数不能为零"
- 格式错误：TTS播报 "无法识别计算表达式"

**代码示例**：
```kotlin
fun calculate(text: String): String? {
    val pattern = """(\d+)\s*(加|减|乘|除以|[\+\-\*/])\s*(\d+)""".toRegex()
    val match = pattern.find(text) ?: return null
    
    val num1 = match.groupValues[1].toDouble()
    val operator = match.groupValues[2]
    val num2 = match.groupValues[3].toDouble()
    
    val result = when (operator) {
        "加", "+" -> num1 + num2
        "减", "-" -> num1 - num2
        "乘", "*", "×" -> num1 * num2
        "除以", "除", "/", "÷" -> {
            if (num2 != 0.0) num1 / num2 else return "除数不能为零"
        }
        else -> return null
    }
    
    return "等于${result.toInt()}"
}
```

---

### 4.4 单位换算

#### 功能4.4.1：长度换算

**功能描述**：执行长度单位换算

**支持的指令**：
```
- "100公里等于多少米"
- "10米等于多少厘米"
- "1000米等于多少公里"
- "100公里换算成米"
```

**识别规则**：
```
关键词匹配：
- 包含数字
- 包含长度单位：公里、米、厘米、毫米、千米等
- 包含"等于"或"换算"
```

**执行逻辑**：
```kotlin
1. 从指令中提取源数值和单位
2. 从指令中提取目标单位
3. 执行单位换算
4. 返回结果
```

**反馈内容**：
- 成功：TTS播报 "100公里等于100000米"

**单位换算表**：
```
1公里 = 1000米 = 100000厘米 = 1000000毫米
```

---

## 五、对话交互模块（真实实现）

### 5.1 语音识别

#### 功能5.1.1：开始语音识别

**功能描述**：开始识别用户语音输入

**执行流程**：
```
1. 用户点击麦克风按钮
2. 检查录音权限
3. 如果没有权限：
   - 请求权限
   - 提示用户授权
4. 如果有权限：
   - 初始化百度语音识别SDK
   - 开始录音
   - 显示"正在聆听..."状态
   - 显示音量波形动画
```

**状态反馈**：
- 准备中：UI显示"准备中..."
- 聆听中：UI显示"正在聆听..."，显示波形动画
- 识别中：UI显示"识别中..."
- 识别完成：UI显示识别结果

**错误处理**：
- 权限被拒绝：提示"需要录音权限才能使用语音功能"
- 网络错误：提示"网络连接失败，请检查网络"
- 识别超时：提示"识别超时，请重试"
- 无识别结果：提示"没听清，请再说一遍"

---

#### 功能5.1.2：实时识别反馈

**功能描述**：显示实时识别结果（部分结果）

**执行逻辑**：
```kotlin
1. SDK返回部分识别结果（onAsrPartialResult）
2. 在UI上实时显示识别的文字
3. 用户可以随时停止或确认
```

**UI显示**：
- 实时显示识别到的文字
- 文字可能不完整（随着识别更新）

---

#### 功能5.1.3：最终识别结果

**功能描述**：获取最终的识别结果

**执行逻辑**：
```kotlin
1. SDK返回最终识别结果（onAsrFinalResult）
2. 显示完整识别文字
3. 触发意图识别流程
```

**识别结果处理**：
- 保存到对话历史
- 传递给意图识别模块
- 清空识别状态

---

### 5.2 语音合成

#### 功能5.2.1：文本转语音

**功能描述**：将文本转换为语音并播放

**执行流程**：
```
1. 接收需要播报的文本
2. 初始化百度TTS SDK（如果未初始化）
3. 调用TTS API合成语音
4. 播放合成的语音
5. 显示播放状态
```

**反馈内容**：
- 播放开始：UI显示播放图标
- 播放完成：隐藏播放图标
- 播放错误：提示"语音播报失败"

**TTS参数设置**：
- 发音人：可选择男声/女声
- 语速：0-15（默认5）
- 音调：0-15（默认5）
- 音量：0-15（默认5）

---

### 5.3 意图识别

#### 功能5.3.1：解析用户意图

**功能描述**：从识别结果中解析用户意图

**执行流程**：
```
1. 接收语音识别的文字结果
2. 文本预处理（转小写、去除标点等）
3. 关键词匹配
4. 意图分类
5. 参数提取
6. 返回解析结果
```

**意图分类**：
- 媒体控制意图
- 系统控制意图
- 车辆控制意图
- 信息查询意图
- 未知意图

**参数提取**：
- 温度值（如"26度"）
- 城市名称（如"北京"）
- 计算表达式（如"100+200"）
- 颜色名称（如"蓝色"）

---

#### 功能5.3.2：意图匹配规则

**匹配优先级**：
```
1. 完全匹配（最高优先级）
2. 关键词匹配
3. 模糊匹配（最低优先级）
```

**匹配策略**：
- 先匹配明确的意图（如"播放音乐"）
- 再匹配通用的意图（如"播放"）
- 最后匹配模糊的意图

---

### 5.4 对话管理

#### 功能5.4.1：保存对话历史

**功能描述**：保存用户和系统的对话记录

**保存内容**：
- 用户输入（语音识别结果）
- 系统反馈（TTS播报内容）
- 时间戳
- 意图类型

**存储方式**：
- 内存存储（当前会话）
- 数据库存储（可选，持久化）

---

#### 功能5.4.2：多轮对话支持（可选，简化版）

**功能描述**：支持基于上下文的对话

**示例**：
```
用户："温度调高"
系统："温度已调高至25度"
用户："再高一点"  （基于上下文，知道是调温度）
系统："温度已调高至26度"
```

**实现逻辑**：
```kotlin
1. 保存上一轮对话的意图
2. 如果当前指令不完整（如"再高一点"）
3. 结合上一轮意图进行解析
4. 执行操作
```

---

## 功能统计

### 功能总数统计

| 模块 | 功能数量 | 真实实现 | Mock实现 |
|------|---------|---------|---------|
| 媒体控制 | 9 | 9 | 0 |
| 系统控制 | 8 | 7 | 1 |
| 车辆控制 | 30+ | 0 | 30+ |
| 信息查询 | 7 | 7 | 0 |
| 对话交互 | 6 | 6 | 0 |
| **总计** | **60+** | **29** | **31+** |

---

## 下一步

现在功能设计已经非常详细了，每个功能都包含：
- ✅ 功能描述
- ✅ 支持的指令变体
- ✅ 识别规则
- ✅ 执行逻辑
- ✅ 反馈内容
- ✅ 边界情况处理
- ✅ 依赖和权限

可以开始：
1. 设计代码架构
2. 实现意图识别逻辑
3. 实现各个执行器
4. 集成百度SDK

需要我继续哪个部分？

